// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go

// Package cron is a generated GoMock package.
package cron

import (
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
)

// MockScheduler is a mock of Scheduler interface.
type MockScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerMockRecorder
}

// MockSchedulerMockRecorder is the mock recorder for MockScheduler.
type MockSchedulerMockRecorder struct {
	mock *MockScheduler
}

// NewMockScheduler creates a new mock instance.
func NewMockScheduler(ctrl *gomock.Controller) *MockScheduler {
	mock := &MockScheduler{ctrl: ctrl}
	mock.recorder = &MockSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduler) EXPECT() *MockSchedulerMockRecorder {
	return m.recorder
}

// DoEvery mocks base method.
func (m *MockScheduler) DoEvery(interval time.Duration, singletonMode bool, jobFun interface{}) (Job, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoEvery", interval, singletonMode, jobFun)
	ret0, _ := ret[0].(Job)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoEvery indicates an expected call of DoEvery.
func (mr *MockSchedulerMockRecorder) DoEvery(interval, singletonMode, jobFun interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoEvery", reflect.TypeOf((*MockScheduler)(nil).DoEvery), interval, singletonMode, jobFun)
}

// RunAll mocks base method.
func (m *MockScheduler) RunAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RunAll")
}

// RunAll indicates an expected call of RunAll.
func (mr *MockSchedulerMockRecorder) RunAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunAll", reflect.TypeOf((*MockScheduler)(nil).RunAll))
}

// MockJob is a mock of Job interface.
type MockJob struct {
	ctrl     *gomock.Controller
	recorder *MockJobMockRecorder
}

// MockJobMockRecorder is the mock recorder for MockJob.
type MockJobMockRecorder struct {
	mock *MockJob
}

// NewMockJob creates a new mock instance.
func NewMockJob(ctrl *gomock.Controller) *MockJob {
	mock := &MockJob{ctrl: ctrl}
	mock.recorder = &MockJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJob) EXPECT() *MockJobMockRecorder {
	return m.recorder
}

// LastRun mocks base method.
func (m *MockJob) LastRun() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastRun")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// LastRun indicates an expected call of LastRun.
func (mr *MockJobMockRecorder) LastRun() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastRun", reflect.TypeOf((*MockJob)(nil).LastRun))
}

// NextRun mocks base method.
func (m *MockJob) NextRun() time.Time {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NextRun")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// NextRun indicates an expected call of NextRun.
func (mr *MockJobMockRecorder) NextRun() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NextRun", reflect.TypeOf((*MockJob)(nil).NextRun))
}

// RunCount mocks base method.
func (m *MockJob) RunCount() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunCount")
	ret0, _ := ret[0].(int)
	return ret0
}

// RunCount indicates an expected call of RunCount.
func (mr *MockJobMockRecorder) RunCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunCount", reflect.TypeOf((*MockJob)(nil).RunCount))
}
